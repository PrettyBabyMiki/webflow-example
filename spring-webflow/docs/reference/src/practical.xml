<?xml version="1.0" encoding="UTF-8"?>
<chapter id="practical">
	<title>Practical Use of Spring Web Flow</title>
    <sect1 id="samples">
    	<title>Sample applications</title>
    	<para>
			It is recommended that you review the Spring Web Flow sample applications included in the 
			release distribution for best-practice illustrations of the features of this framework.
			A description of each sample is provided below:
    	</para>
    	<para>
    		<orderedlist>
    			<listitem>
    				<para>
    					<ulink url="http://www.ervacon.com/products/swf/intro/index.html">Phonebook</ulink> - the original sample demonstrating most features (including subflows).
    				</para>
    			</listitem>
    			<listitem>
    				<para>
    					<link linkend="fileupload-sample">Fileupload</link> - demonstrates multipart file upload.
    				</para>
    			</listitem>
    			<listitem>
    				<para>
    					<link linkend="birthdate-sample">Birthdate</link> - demonstrates Struts integration and the MultiAction.
    				</para>
    			</listitem>
    			<listitem>
    				<para>
    					<link linkend="shippingrate-sample">Shippingrate</link> - demonstrates Spring Web Flow together with Ajax technology.
    				</para>
    			</listitem>
    			<listitem>
    				<para>
    					<link linkend="numberguess-sample">NumberGuess</link> - demonstrates use of stateful middle-tier components to carry out business logic.
    				</para>
    			</listitem>
    			<listitem>
    				<para>Sellitem - demonstrates a wizard with conditional transitions, flow scope, flow execution redirects, and continuations.</para>
    			</listitem>
    			<listitem>
    				<para>Flowlauncher - demonstrates all the possible ways to launch and resume flows.</para>
    			</listitem>
    			<listitem>
    				<para>Itemlist - demonstrates REST-style URLs and inline flows.</para>
    			</listitem>
    			<listitem>
    				<para>Phonebook-Portlet - the phonebook sample in a Portlet environment (notice how the flow definitions do not change).</para>
    			</listitem>
    			<listitem>
    				<para>Sellitem-JSF - the sellitem sample in a JSF environment (notice how the flow definition is more concise because
    				JSF takes care of data binding and validation).</para>
    			</listitem>
    		</orderedlist>
    	</para>
    </sect1>
    <sect1 id="running-samples">
    	<title>Running the Web Flow sample applications</title>
    	<para>
    		The samples can be built from the command line and imported as Eclipse projects - all samples come
    		with Eclipse project settings. It is also possible to start by importing the samples into Eclipse
    		first and then build with Ant within Eclipse.
    	</para>
    	<sect2>
    		<title>Building from the Command Line</title>
    		<para>
    			Java 1.5 (or greater) and Ant 1.6 (or greater) are prerequisites for building the sample applications.
    			Ensure those are present in the system path or are passed on the command line. To build Web Flow 
    			samples from the command line, open a prompt, cd to the directory where Spring Web Flow was
    			unzipped and run the following:
    			<programlisting>
cd projects/spring-webflow/build-spring-webflow
ant dist
				</programlisting>
				This builds all samples preparing "target" areas within each sample project subdirectory
				containing webapp structures in both exploded and WAR archive forms. The build also provides basic helper targets
				for deploying to Tomcat from Ant; however these webapp structures can be copied to any servlet container,
				and each project is also a Eclipse Dynamic Web Project (DWP) for easy deployment inside Eclipse 
				with the Eclipse Webtools Project (WTP).
    		</para>
    	</sect2>
    	<sect2>
    		<title>Importing Projects into Eclipse</title>
    		<para>
    			Importing the sample projects into Eclipse is easy. With a new or an existing workspace select:
    			<emphasis>File &gt; Import &gt; Existing Projects into Workspace</emphasis>. In the resulting dialog browse to the project
    			subdirectory where Spring Web Flow was unzipped and choose it as the root directory to import from.
    			Select OK. Here Eclipse will list all projects it found including the sample application projects.
    			Select the projects you're interested in, and select Finish.
    		</para>
    		<para>
    			If you previously built each project from the command line Eclipse will compile with no errors.
    			If not you will need to run the Ant build <emphasis>once</emphasis> for these errors to clear
    			and you can do that within Eclipse.
    		</para>
    		<para>
    			To build all projects inside Eclipse, import and expand the <literal>build-spring-webflow</literal> project, right-click on 
    			<literal>build.xml</literal> and select <emphasis>Run As &gt; Ant Build</emphasis>.
    			Doing this will run the default Ant target and will build all sample projects.
    		</para>
    		<para>
    			To build a single project inside Eclipse, simply select the project, right-click, and
    			select <emphasis>Run As &gt; Ant Build</emphasis>.  You can also use the convenient
    			shortcut ALT + SHIFT + X (Execute menu), then Q (Run Ant Build).
    		</para>
    		<para>
    			After Ant runs and the libraries needed to compile each project are downloaded,
    			all errors in the Eclipse problems view should go away. Try refreshing a project (F5)
    			if you still have errors.  In general, from this point on you no longer need Ant: you 
    			can rely on Eclipse's incremental compile and Eclipse's 	web tools (WTP) built-in JEE support
    			for deployment. (Ant is only needed in the system for command-line usage or when the list of
    			jar dependencies for a project changes and new jars need to be downloaded).
    		</para>
    	</sect2>
    	<sect2>
    		<title>Deploying projects inside Eclipse using Eclipse Web Tools (WTP)</title>
    		<para>
    			Each Spring Web Flow sample application project is a Eclipse Dynamic Web Project (DWP), 
    			for easy deployment to a server running inside the Eclipse IDE.  To take advantage 
    			of this, you must be running Eclipse 3.2 with Web Tools 1.5.
	    	</para>
	    	<para>
	    		To run a sample application as a webapp inside Eclipse, simply select the project, 
	    		right-click, and select <emphasis>Run -> Run On Server</emphasis>.  A convenient 
	    		shortcut for this action is ALT + SHIFT + X (Execute menu), R (Run on Server).
	    		The first time you do this you will be asked to setup a Server, where you are 
	    		expected to point Eclipse to a location where you have a Servlet Container
	    		such as Apache Tomcat installed.  Once your container has been setup and you finish the 
	    		deployment wizard, Eclipse will start the container and automatically publish 
	    		your webapp to it.  In addition, it will launch a embedded web browser allowing you
	    		to run the webapp fully inside the IDE.
	    	</para>
	    </sect2>
    	<sect2>
    		<title>Other IDE's</title>
    		<para>
    			Importing samples into other IDE's should be fairly straight-forward. If using another IDE
    			running the Ant build from the command line first may help as it will populate the lib
    			subdirectories of each sample project. Follow steps similar as those outlined for Eclipse above.
    		</para>
    	</sect2>
    </sect1>
    <sect1 id="fileupload-sample">
    	<title>Fileupload Example</title>
    	<sect2>
    		<title>Overview</title>
    		<para>
    			Fileupload is a simple one page web application for uploading files to a server. It is based
    			on Spring MVC, uses a Web Flow controller and one web flow with two states: a view state for
    			displaying the initial JSP page and an action state for processing the submit.	
    		</para>
    	</sect2>
    	<sect2>
    		<title>Web.xml</title>
    		<para>
    			The web.xml configuration maps requests for "*.htm" to the fileupload servlet - a regular
    			Spring MVC DispatcherServlet:
    			<programlisting>
&lt;servlet&gt;
	&lt;servlet-name&gt;fileupload&lt;/servlet-name&gt;
	&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
	 
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;fileupload&lt;/servlet-name&gt;
	&lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
				</programlisting>
    		</para>
    	</sect2>
    	<sect2>
    		<title>Spring MVC Context</title>
    		<para>
    			The Spring MVC servlet context for the fileupload servlet (WEB-INF/fileupload-servlet.xml) defines
    			one controller bean:
    			<programlisting>
&lt;bean name="/admin.htm" class="org.springframework.webflow.executor.mvc.FlowController"&gt;
	&lt;property name="flowExecutor" ref="flowExecutor" /&gt;
&lt;/bean&gt;
				</programlisting>
				FlowController is a Web Flow controller. It is the main point of integration between Spring MVC
				and Spring Web Flow routing requests to one or more managed web flow executions. The
				FlowController is injected with flowExecutor and flowRegistry beans containing one web flow
				definition:
				<programlisting>
&lt;!-- Launches new flow executions and resumes existing executions. --&gt;
&lt;flow:executor id="flowExecutor" registry-ref="flowRegistry" repository-type="singlekey"/&gt;
	
&lt;!-- Creates the registry of flow definitions for this application --&gt;
&lt;flow:registry id="flowRegistry"&gt;
	&lt;flow:location path="/WEB-INF/fileupload.xml" /&gt;
&lt;/flow:registry&gt;
				</programlisting>
				Given the above definitions the following URI can be used to invoke the "fileupload" flow:
				<programlisting>
/swf-fileupload/admin.htm?_flowId=fileupload
				</programlisting>
    		</para>
    		<para>
    			Both flowExecutor and flowRegistry beans are defined with Spring custom tags schema available in
    			Spring 2.0. The custom tags make configuration less verbose and more readable. Regular Spring
    			bean definitions can be used as well with earlier versions of Spring.
    		</para>
    		<para>
				The Spring MVC context also defines a view resolver bean for resolving logical view names and a
				multipartResolver bean for the upload component. In general Web Flow does not aim to replace the
				flexibility of Spring MVC for view resolution. It focuses on the C in MVC.
    		</para>
    	</sect2>
    	<sect2>
    		<title>Fileupload Web Flow</title>
    		<para>
    			The start state for the fileupload flow (WEB-INF/fileupload.xml) is a view state:
    			<programlisting>
&lt;start-state idref="selectFile"/&gt;

&lt;view-state id="selectFile" view="fileForm"&gt;
	&lt;transition on="submit" to="uploadFile"/&gt;
&lt;/view-state&gt;
				</programlisting>
				View states allow a user to participate in a flow by presenting a suitable interface.
				The view attribute "fileForm" is a logical view name, which the Spring MVC view resolver bean
				will resolve to /WEB-INF/jsp/fileForm.jsp.
			</para>
			<para>
				The fileForm.jsp has an html form that submits back to the same controller
				(/swf-fileupload/admin.htm) and passes a "_flowExecutionKey" parameter.
				The value for _flowExecutionKey is provided by the FlowController - it identifies the current
				instance of the flow and allows Web Flow to resume flow execution, which is paused each time a
				view is displayed.
    		</para>
    		<para>
    			The name of the form submit button "_eventId_submit" indicates the event id to use for deciding
    			where to transition to next. Given an event with id of "submit" the "selectFile" view transitions
    			to the "uploadFile" state:
    			<programlisting>
&lt;action-state id="uploadFile"&gt;
	&lt;action bean="uploadAction" method="uploadFile"/&gt;
	&lt;transition on="success" to="selectFile"&gt;
		&lt;set attribute="fileUploaded" scope="flash" value="true"/&gt;
	&lt;/transition&gt;
	&lt;transition on="error" to="selectFile"/&gt;
&lt;/action-state&gt;
				</programlisting>
    		</para>
    		<para>
    			The "uploadFile" state is an action state. Action states integrate with business application code and
    			respond to the execution of that code by deciding what state of the flow to enter next. The code for the
    			uploadFile state is in the "uploadAction" bean declared in the Spring web context (/WEB-INF/fileupload-servlet.xml):
    			<programlisting>
&lt;bean id="uploadAction" class="org.springframework.webflow.samples.fileupload.FileUploadAction" /&gt;
				</programlisting>
				FileUploadAction has simple logic. It picks one of two Web Flow defined events - success or error,
				depending on whether the uploaded file size is greater than 0 or not. Both success and error
				transition back to the "selectFile" view state. However, a success event causes an attribute named
				"fileUploaded" to be set in flash scope
    		</para>
    		<para>
    			A flash-scoped attribute called "file" is also set programmatically in the FileUploadAction bean:
    			<programlisting>
context.getFlashScope().put("file", new String(file.getBytes()));
return success();
				</programlisting>
				This illustrates the choice to save attributes in one of several scopes either programatically or
				declaratively. 
    		</para>
    	</sect2>
    </sect1>
    <sect1 id="birthdate-sample">
    	<title>Birthdate Example</title>
    	<sect2>
    		<title>Overview</title>
    		<para>
    			Birthdate is a web application with 3 consequitive screens. The first two collect user input
    			to populate a form object. The third presents the results of business calculations based on
    			input provided in the first two screens.
    		</para>
    		<para>
    			Birthdate demonstrates Spring Web Flow's Struts integration as well as the use of FormAction,
    			a multi-action used to do the processing required for all three screens. The sample also uses JSTL
    			taglibs in conjunction with flows.
    		</para>
    	</sect2>
    	<sect2>
    		<title>Web.xml</title>
    		<para>
    			The web.xml configuration maps requests for "*.do" to a regular Struts ActionServlet:
    			<programlisting>
&lt;servlet&gt;
	&lt;servlet-name&gt;action&lt;/servlet-name&gt;
	&lt;servlet-class&gt;org.apache.struts.action.ActionServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
	 
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;action&lt;/servlet-name&gt;
	&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
				</programlisting>
				The web.xml also sets up the loading of a Spring context at web application startup:
				<programlisting>
&lt;context-param&gt;
	&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
	&lt;param-value&gt;
		/WEB-INF/webflow-config.xml
	&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
	&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
				</programlisting>
				The Spring web context contains beans to set up the Web Flow runtime environment. As will be
				shown in the next section Struts is configured with a Web Flow action that relies on the
				presence of a flowExecutor and a flowRegistry beans in this context.
    		</para>
    	</sect2>
    	<sect2>
    		<title>Struts Configuration</title>
    		<para>
    			The Struts configuration (WEB-INF/struts-config.xml) defines the following action mapping:
    			<programlisting>
&lt;action-mappings&gt;
	&lt;action path="/flowAction" name="actionForm" scope="request"
		type="org.springframework.webflow.executor.struts.FlowAction"/&gt;
&lt;/action-mappings&gt;
				</programlisting>
				FlowAction is a Struts action acting as a front controller to the Web Flow system routing Struts
				requests to one or more managed web flow executions. To fully configure the FlowAction a Spring
				web context is required to define flowExecutor and flowRegistry beans (named exactly so). This is
				an excerpt from the Spring web context (/WEB-INF/webflow-config.xml) defining these beans:
				<programlisting>
&lt;!-- Launches new flow executions and resumes existing executions. --&gt;	
&lt;flow:executor id="flowExecutor" registry-ref="flowRegistry"/&gt;
	
&lt;!-- Creates the registry of flow definitions for this application --&gt;
&lt;flow:registry id="flowRegistry"&gt;
	&lt;flow:location path="/WEB-INF/birthdate.xml"/&gt;
	&lt;flow:location path="/WEB-INF/birthdate-alternate.xml"/&gt;
&lt;/flow:registry&gt;
				</programlisting>
    		</para>
    		<para>
    			Based on the above, Web Flow is configured with two flows - birthdate and birthdate-alternate,
    			which can be invoked as follows:
    			<programlisting>
/swf-birthdate/flowAction.do?_flowId=birthdate
/swf-birthdate/flowAction.do?_flowId=birthdate-alternate
				</programlisting>
				The Struts configuration file also defines several global forwards: birthdateForm, cardForm,
				and yourAge, which will be referenced from Web Flow definitions as logical view names
				(and left to Struts to resolve to actual JSP pages). In general Web Flow does not aim to replace
				view resolution capabilities of web frameworks such as Struts or Spring MVC.
				It focuses on the C in MVC.
    		</para>
    	</sect2>
    	<sect2>
    		<title>Birthdate Web Flow</title>
    		<para>
    			The birthdate web flow (WEB-INF/birthdate.xml) defines the following start state:
    			<programlisting>
&lt;view-state id="enterBirthdate" view="birthdateForm"&gt;
	&lt;render-actions&gt;
		&lt;action bean="formAction" method="setupForm" /&gt;
	&lt;/render-actions&gt;
	&lt;transition on="submit" to="processBirthdateFormSubmit" /&gt;
&lt;/view-state&gt;
				</programlisting>
				The setupForm action is called to perform initializations for the enterBirthdate view state.
				Its action bean is defined the Spring web context WEB-INF/webflow-config.xml:
				<programlisting>
&lt;bean id="formAction" class="org.springframework.webflow.samples.birthdate.BirthDateFormAction" /&gt;
				</programlisting>
				BirthDateFormAction is a FormAction - it extends Web Flow's FormAction class, which serves a
				purpose similar to that of Spring MVC's SimpleFormController providing common form functionality
				for data binding and validation. 
    		</para>
    		<para>
    			When the BirthDateFormAction bean is instantiated it sets the name, class and scope of the form
    			object to use for loading form data upon display and collecting form data upon submit:
    			<programlisting>
public BirthDateFormAction() {
	// tell the superclass about the form object and validator we want to
	// use you could also do this in the application context XML ofcourse
	setFormObjectName("birthDate");
	setFormObjectClass(BirthDate.class);
	setFormObjectScope(ScopeType.FLOW);
	setValidator(new BirthDateValidator());
}
				</programlisting>
				The form object "birthDate" is placed in flow scope, which means it will not be re-created with
				each request but will be obtained from flow scope instead as long as the request remains within
				the same flow.
    		</para>
    		<para>
    			Once setupForm is done, the "birthdateForm" view will be rendered.
				The logical view name "birthdateForm" is a global-forward in struts-config.xml resolving to
				/WEB-INF/jsp/birthdateForm.jsp. This JSP collects data for the fields "name" and "date" bound to
				the birthDate form object and posts back to FlowAction with a submit image named
				"_eventId_submit". An event with the id of "submit" causes a transition to the
				processBirthdateFormSubmit action state defined as follows: 
				<programlisting>
&lt;action-state id="processBirthdateFormSubmit"&gt;
	&lt;action bean="formAction" method="bindAndValidate"&gt;
		&lt;attribute name="validatorMethod" value="validateBirthdateForm" /&gt;
	&lt;/action&gt;
	&lt;transition on="success" to="enterCardInformation" /&gt;
	&lt;transition on="error" to="enterBirthdate" /&gt;
&lt;/action-state&gt;
				</programlisting>
				The processBirthDateFormSubmit action state uses the same formAction bean as the one already used
				to setup the form. This time its bindAndValidate
				method is used to populate and validate the html form values. Also, note the "validateMethod"
				attribute used to specify the name of the method to invoke on the Validator object setup in the
				constructor of the BirthDateFormAction. The use of this attribute allows partial validation of
				complex objects populated over several consecutive screens.
    		</para>
    		<para>
    			On error the action returns to the view state it came from. On success it transitions to the
    			enterCardInformation view state:
    			<programlisting>
&lt;view-state id="enterCardInformation" view="cardForm"&gt;
	&lt;transition on="submit" to="processCardFormSubmit" /&gt;
&lt;/view-state&gt;
				</programlisting>
				The logical view name "cardForm" is a global-forward in struts-config.xml resolving to
				/WEB-INF/jsp/cardForm.jsp. This JSP collects data for the remaining fields of the birthDate form
				object - "sendCard" and "emailAddress", and posts back to FlowAction with a submit image named
				"_eventId_submit". An event with the id of "submit" causes a transition to the
				processCardFormSubmit action state defined as follows:
				<programlisting>
&lt;action-state id="processCardFormSubmit"&gt;
	&lt;action bean="formAction" method="bindAndValidate"&gt;
		&lt;attribute name="validatorMethod" value="validateCardForm" /&gt;
	&lt;/action&gt;
	&lt;transition on="success" to="calculateAge" /&gt;
	&lt;transition on="error" to="enterCardInformation" /&gt;
&lt;/action-state&gt;
				</programlisting>
				For this action state the bindAndValidate method of the formAction bean is used to populate and
				validate the remaining html form values. The "validateMethod" attribute specifies the name of the
				method to invoke on the Validator object specific to the fields loaded on the current screen.
    		</para>
    		<para>
    			On error the action returns to the view state it came from. On success it transitions to another
    			action state called calculateAge:
    			<programlisting>
&lt;action-state id="calculateAge"&gt;
	&lt;action bean="formAction" method="calculateAge" /&gt;
	&lt;transition on="success" to="displayAge" /&gt;
&lt;/action-state&gt;
				</programlisting>
				The logic for the calculateAge action state is in the calculateAge method of the same formAction
				bean used for data binding and validation. This demonstrates the flexibility Web Flow allows in
				properly structuring control and business logic according to function.
	 		</para>
	 		<para>
	 			The caculateAge method performs business calculations and adds a string in request scope with the
	 			calculated age. Upon successful completion the calculateAge action state transitions to the end
	 			view state:
	 			<programlisting>
&lt;end-state id="displayAge" view="yourAge" /&gt;
				</programlisting>
				Once again the logical view name "yourAge" is a global-forward in struts-config.xml resolving to
				/WEB-INF/jsp/yourAge.jsp. This JSP page retrieves the calculated age from request scope and
				displays the results for the user.
	 		</para>
	 		<para>
	 			The transition to the end state indicates the end of the web flow. The flow execution is cleaned up.
	 			If the web flow is entered again a new flow execution will start, creating a new form
	 			object named "birthDate" and placing it in flow scope.
	 		</para>
    	</sect2>
    	<sect2>
    		<title>Birthdate-alternate Web Flow</title>
    		<para>
    			The birthdate-alternate web flow (/WEB-INF/birthdate-alternate.xml) offers an alternative way and
    			more compact way of defining the same web flow. For example the birthdate web flow defines two
    			independent states for the first screen - a view state (enterBirthdate) and an action state
    			(processBirthdateFormSubmit). In birthdate-alternate those are encapsulated in the view state
    			enterBirthdate as follows:
    			<programlisting>
&lt;view-state id="enterBirthdate" view="birthdateForm"&gt;
	&lt;render-actions&gt;
		&lt;action bean="formAction" method="setupForm" /&gt;
	&lt;/render-actions&gt;
	&lt;transition on="submit" to="enterCardInformation"&gt;
		&lt;action bean="formAction" method="bindAndValidate"&gt;
			&lt;attribute name="validatorMethod" value="validateBirthdateForm" /&gt;
		&lt;/action&gt;
	&lt;/transition&gt;
&lt;/view-state&gt;
				</programlisting>
				Here the setupForm action state is defined as a render-action of the enterBirthdate view state
				while the transition to the next screen uses a nested action bean invoked before the transition
				occurs. Notice that success is implicitly required for the transition to occur. Similarly on error
				the transition does not occur and the same view state is displayed again.
    		</para>
    		<para>
    			The second screen is also defined with a nested transition and action bean:
    			<programlisting>
&lt;view-state id="enterCardInformation" view="cardForm"&gt;
	&lt;transition on="submit" to="calculateAge"&gt;
		&lt;action bean="formAction" method="bindAndValidate"&gt;
			&lt;attribute name="validatorMethod" value="validateCardForm" /&gt;
		&lt;/action&gt;
	&lt;/transition&gt;
&lt;/view-state&gt;
				</programlisting>
				The remaining two states - calculateAge and displayAge are identical.
    		</para>
    	</sect2>
    </sect1>
    <sect1 id="shippingrate-sample">
        <title>Shippingrate Example</title>
        <sect2>
            <title>Overview</title>
            <para>
                The Shippingrate sample demonstrates the use of Spring Web Flow in combination with 
                Ajaxian techniques. It consists of several wizard-style steps executed 
                with Ajax requests and refreshing a portion of the page.
                The input is collected from the user in incremental steps. It is stored 
                in a flow-scoped object and is then used to calcualte a shipping rate.
                The example also demonstrates invocation of a service-layer bean
                defined in a Spring context to perform calculations and
                to provide reference data such as countries and package types.
            </para>
        </sect2>
        <sect2>
            <title>Web.xml</title>
            <para>
                The web.xml configuration maps requests for "*.htm" to the 
                shippingrate servlet - a regular Spring MVC DispatcherServlet:
                <programlisting>
&lt;servlet&gt;
    &lt;servlet-name&gt;shippingrate&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;shippingrate&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
                </programlisting>
                The web.xml also ensures the following Spring context file is loaded 
                at runtime from the web application classpath:
                <programlisting>
&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;
        classpath:org/springframework/webflow/samples/shippingrate/domain/services.xml
    &lt;/param-value&gt;
&lt;/context-param&gt;
                </programlisting>
                The services.xml Spring context defines a "rateService" bean providing 
                operations for making shipping rate calculations and for retrieving 
                reference data required for display in the JSP pages of the application.
            </para>
        </sect2>
        <sect2>
            <title>Spring MVC Context</title>
            <para>
                The Spring MVC servlet context for the shippingrate servlet (WEB-INF/shippingrate-servlet.xml) 
                defines one controller bean:
                <programlisting>
&lt;bean name="/rates.htm" class="org.springframework.webflow.executor.mvc.FlowController"&gt;
    &lt;property name="flowExecutor" ref="flowExecutor" /&gt;
&lt;/bean&gt;
                </programlisting>
                FlowController is a Web Flow controller. It is the main point of integration between Spring MVC
                and Spring Web Flow routing requests to one or more managed web flow executions. The
                FlowController is injected with flowExecutor and flowRegistry beans:
                <programlisting>
&lt;!-- Launches new flow executions and resumes existing executions. --&gt;
&lt;flow:executor id="flowExecutor" registry-ref="flowRegistry" repository-type="simple"/&gt;
    
&lt;!-- Creates the registry of flow definitions for this application --&gt;
&lt;flow:registry id="flowRegistry"&gt;
    &lt;flow:location path="/WEB-INF/flows/**/*-flow.xml" /&gt;
&lt;/flow:registry&gt;
                </programlisting>
                The flowExecutor and the flowRegistry beans collectively configure
                the FlowController with one web flow - the getRate-flow defined in
                /WEB-INF/flows/getRate-flow.xml. The flowExecutor uses a "simple"
                repository, which manages execution state in the user session.
            </para>
            <para>
                Given the above definitions the following URI  can be used to initiate 
                the getRate-flow:
                <programlisting>
/swf-shippingrate/rates.htm?_flowId=getRate-flow
                </programlisting>
            </para>
        </sect2>
        <sect2>
            <title>Ajax Requests</title>
            <para>
                The shippingrate example consists of several wizard-style steps.
                After the initial index.jsp subsequent pages are 
                loaded in an Ajax manner without reloading the entire page.
            </para>
            <warning>
                <para>
                    This sample has been tested successfully on Internet Explorer 6 and 7, 
                    Firefox 2.0, and Safari 2. There are known Javascript issues 
                    with use on Firefox 1.5.
                </para>
            </warning>
            <para>
                The Ajax requests are done with the help of the
                <ulink url="http://prototype.conio.net">Prototype</ulink>
                framework and a thin JavaScript layer over it providing
                convenient functions for processing Ajax form and get requests.
                The required Javascript libraries are included in index.jsp as follows:
                <programlisting>
&lt;script src="prototype.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="swf_ajax.js" type="text/javascript"&gt;&lt;/script&gt;
                </programlisting>
            </para>
            <para>
                When index.jsp is loaded the following JavaScript invokes the getRate-flow
                and replaces the content of the getRateWizard div tag with the response
                returned from the server:
                <programlisting>
&lt;div id="getRateWizard"&gt;
    &lt;script type="text/javascript"&gt;
    window.onload = function() {
        new SimpleRequest('getRateWizard', 'rates.htm', 'get', '_flowId=getRate-flow');
    };
    &lt;/script&gt;
&lt;/div&gt;
                </programlisting>
                Functions are first-class citizens and a type in JavaScript. 
                The script above creates an instance of
                the SimpleRequest function defined in swf_ajax.js. This function invokes
                Prototype's Ajax.Updater with the specified URL and request parameters. On success
                the content of the getRateWizard div is replaced with the response returned
                from the server. On failure such as an HTTP response code other 200 (OK) 
                an error message is displayed.
            </para>
            <para>
                The next few pages are form-based JSP's - selectCustomer.jsp, selectReceiver.jsp, 
                etc. Each of them contains the following JavaScript call at the bottom:
                <programlisting>
&lt;script type="text/javascript"&gt;
    formRequest('selectCustomerTypeForm');
&lt;/script&gt;
                </programlisting>
                The formRequest function is also defined in swf_ajax.js 
                and it uses Prototype to register a handler for the form submit event:
                <programlisting>
function formRequest(formElementId) {
    Event.observe(formElementId, 'submit', handleSubmitEvent, true);
}
                </programlisting>
                The handleSubmitEvent function extracts the form parameters, stops the 
                submit event, and posts an AJAX request via XMLHttpRequest. On success
                the results returned form the server replace the content of the form.
                On failure such as an HTTP response code other 200 (OK) an error 
                message is displayed.
            </para>
            <para>
                Although not demonstrated in this example a back button can be 
                implemented in parallel with the Next button used to advance from
                one screen to the next. This would be necessary because the browser
                back button - a common issue in Ajax applications, contrary to user
                expectation returns to the page prior to the first Ajax request.
            </para>
            <para>
                As a result of the Ajax requests the entire wizard is able to 
                function within a portion of the page without refresing 
                the remaining information on it.
            </para>
        </sect2>
        <sect2>
            <title>getRate Web Flow</title>
            <para>
                The getRate-flow (/WEB-INF/jsp/flows/getRate-flow.xml) defines the following start state:
                <programlisting>
&lt;view-state id="selectCustomerType" view="selectCustomer"&gt;
    &lt;transition on="submit" to="selectSender"&gt;
        &lt;action bean="formAction" method="bind" /&gt;
    &lt;/transition&gt;
&lt;/view-state&gt;
                </programlisting>
                This is a view state, which will display the initial form using the 
                JSP page /WEB-INF/jsp/selectCustomer.jsp. Notice, the use of a start action 
                executed immediately before the JSP is displayed:
                <programlisting>
&lt;start-actions&gt;
    &lt;action bean="formAction" method="setupForm" /&gt;
&lt;/start-actions&gt;
                </programlisting>                
                The "formAction" bean is defined in the Spring servlet context 
                (/WEB-INF/shippingrate-servlet.xml). It specifies a form object
                and  a validator to use for form data binding and validation:
                <programlisting>
&lt;!-- Performs "form backing object" data binding and validation on input submit --&gt;
&lt;bean id="formAction" class="org.springframework.webflow.action.FormAction"&gt;
    &lt;property name="formObjectName" value="rateCriteria" /&gt;
    &lt;property name="formObjectClass" value="org.springframework.webflow.samples.shippingrate.domain.RateCriteria" /&gt;
    &lt;property name="formObjectScope" value="FLOW" /&gt;
    &lt;property name="validator"&gt;
        &lt;bean class="org.springframework.webflow.samples.shippingrate.domain.RateCriteriaValidator" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
                The form object of type RateCriteria will be used to collect data 
                from the user in several steps. The form object will be stored in FLOW scope
                and will not be re-created with each request as long 
                as the flow hasn't reached its end state. The actual binding of
                html form fields to the RateCriteria object is based on
                Spring's data binding mechanism. Html form fields are surrounded
                with the &lt;spring:bind&gt; tag containing the path 
                nested property field. FormAction's bindAndValidate method
                will initiate the actual binding on the server side 
                between HTTP request parameters and RateCriteria data fields.
            </para>
            <para>
                When the selectCustomer.jsp submits back to the FlowController via
                "/swf-shippingrate/rate.htm" it uses a submit button named 
                "_eventId_submit". This indicates to Web Flow a transition to 
                the "selectSender" view state. This view state is defined as follows:
                <programlisting>
&lt;view-state id="selectSender" view="selectSender"&gt;
    &lt;render-actions&gt;
        &lt;bean-action bean="rateService" method="getCountries"&gt;
            &lt;method-result name="countries" /&gt;
        &lt;/bean-action&gt;
    &lt;/render-actions&gt;
    &lt;transition on="submit" to="selectReceiver"&gt;
        &lt;action bean="formAction" method="bindAndValidate"&gt;
            &lt;attribute name="validatorMethod" value="validateSender" /&gt;
        &lt;/action&gt;
    &lt;/transition&gt;
&lt;/view-state&gt;
                </programlisting>
                The selectSender view state has a render action: 
                the "rateService" bean that was loaded through the services.xml context referenced
                in web.xml. The purpose of the render action is to load data required 
                to render the JSP. In this case the rateService bean has a method called
                getCountries that returns a list of countries to be displayed in a drop-down
                by the JSP.
            </para>
            <para>
                The "selectSender" view state also defines one transition: on event with 
                id of "submit" a transition to the "selectReceiver" view state occurs. 
                A pre-requisite for the transition to occur is the successful completion of 
                formAction bean's bindAndValidate method. The attribute "validatorMethod" on
                the bean specifies the name of the method to invoke on the Validator object 
                specifically for the fields of the current screen. 
                If the bindAndValidate method does not succeed the transition does not take
                place and the flow remains in the "selectSender" view 
                state where the user can review the errors and modify the selection.
            </para>
            <para>
                The next two states in the flow - selectReceiver and selectPackageDetails use similar 
                mechnisms. The rateSevice bean is used to retrieve countries and package types for 
                use in the JSP. The form backing object RateCriteria stored in FLOW scope 
                is used to collect user input with each form submit. 
            </para>
            <para>
                The "findRate" action state occurs after all user input has been provided. 
                It is defined as follows:
                <programlisting>
&lt;action-state id="findRate"&gt;
    &lt;bean-action bean="rateService" method="getRate"&gt;
        &lt;method-arguments&gt;
            &lt;argument expression="flowScope.rateCriteria" /&gt;
        &lt;/method-arguments&gt;
        &lt;method-result name="rate" /&gt;
    &lt;/bean-action&gt;
    &lt;transition on="success" to="showRate" /&gt;
&lt;/action-state&gt;
                </programlisting>
                Logic for the action state is provided by the getRate method of 
                the rateService bean. The RateCriteria object stored in FLOW scope
                and containing the user input is passed to the rateService bean.
                The result of the method is exposed in request scope under 
                the name "rate". 
            </para>
            <para>
                The next and final state "showRate" is a JSP page, which accesses the calculated rate 
                information and displays it to the user.
            </para>            
        </sect2>
    </sect1>    
    <sect1 id="numberguess-sample">
        <title>Numberguess Example</title>
        <sect2>
            <title>Overview</title>
            <para>
                Numberguess uses Web Flow to implement two number guessing games.
                For each game the user can enter multiple guesses and depending 
                on the answer either transition back to the same screen or 
                advance to the final screen. Logic for the guessing games is 
                provided through FLOW-scoped beans, which also maintain state
                such as the total number of guesses. The example defines transitions 
                using event pattern matching and custom exception handlers.
            </para>
        </sect2>
        <sect2>
            <title>Web.xml</title>
            <para>
                The web.xml configuration maps "*.htm" requests to the numberguess servlet - 
                a regular Spring MVC DispatcherServlet:
                <programlisting>
&lt;servlet&gt;
    &lt;servlet-name&gt;numberguess&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;numberguess&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.htm&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
                </programlisting>
                The Spring web context is loaded from a file called 
                /WEB-INF/dispatcher-servlet.xml.
            </para>
        </sect2>
        <sect2>
            <title>Spring MVC Context</title>
            <para>
                The Spring MVC web context (WEB-INF/dispatcher-servlet.xml) 
                defines one controller bean:
                <programlisting>
&lt;bean name="/play.htm" class="org.springframework.webflow.executor.mvc.FlowController"&gt;
    &lt;property name="flowExecutor" ref="flowExecutor" /&gt;
&lt;/bean&gt;
                </programlisting>
                FlowController is a Web Flow controller. It is the main point of 
                integration between Spring MVC and Spring Web Flow routing requests 
                to one or more managed web flow executions. The FlowController is 
                injected with flowExecutor and flowRegistry beans:
                <programlisting>
&lt;!-- Launches new flow executions and resumes existing executions. --&gt;
&lt;flow:executor id="flowExecutor" registry-ref="flowRegistry" repository-type="singlekey"/&gt;
    
&lt;!-- Creates the registry of flow definitions for this application --&gt;
&lt;flow:registry id="flowRegistry"&gt;
    &lt;flow:location path="/WEB-INF/higherlower.xml" /&gt;
    &lt;flow:location path="/WEB-INF/mastermind.xml" /&gt;
&lt;/flow:registry&gt;
                </programlisting>
                The flowExecutor and the flowRegistry beans collectively configure
                the FlowController with two web flows - higherlower and mastermind.
                This flowExecutor is configured with a simple repository that assigns 
                a single flow execution key per conversation. The key, once assigned, 
                never changes for the duration of the conversation. 
            </para>
            <para>
                Given the above definitions the following URI's can be used to initiate 
                each of the two flows:
                <programlisting>
/swf-numberguess/play.htm?_flowId=higherlower
/swf-numberguess/play.htm?_flowId=mastermind
                </programlisting>
            </para>
            <para>
                The Spring MVC servlet context also defines a view resolver bean for 
                resolving logical view names. In general Web Flow does not aim 
                to replace the flexibility of Spring MVC for view resolution. 
                It focuses on the C in MVC.
            </para>
        </sect2>
        <sect2>
            <title>Higherlower Flow</title>
            <para>
                The Higherlower flow (/WEB-INF/higherlower.xml) starts with the following 
                flow variable declaration:
                <programlisting>
&lt;var name="game" class="org.springframework.webflow.samples.numberguess.HigherLowerGame"/&gt;
                </programlisting>
                This variable is automatically created when an execution of the flow
                begins and will exist in FLOW scope throughout its duration.
            </para>
            <para>
                The start state for the flow is defined as follows:
                <programlisting>
&lt;view-state id="enterGuess" view="higherlower.enterGuess"&gt;
    &lt;transition on="submit" to="makeGuess"/&gt;
&lt;/view-state&gt;
                </programlisting>
                The view resolver bean of Spring MVC will resolve "higherlower.enterGuess" 
                to /WEB-INF/jsp/higherlower.enterGuess.jsp.
                This JSP has a form with one input field for the guess number.
                The "game" variable referenced throughout the JSP 
                is the FLOW-scoped variable that was declared at the top of 
                the flow definition.
            </para>
    	    <para>
        		The name of the form submit button "_eventId_submit" indicates the 
                event id to use for deciding where to transition to next. Given an 
                event with id of "submit" the "enterGuess" view state transitions
    			to the "makeGuess" action state defined as follows:
                <programlisting>
&lt;action-state id="makeGuess"&gt;
    &lt;evaluate-action expression="flowScope.game.makeGuess(requestParameters.guess)"&gt;
        &lt;evaluation-result name="guessResult"/&gt;
    &lt;/evaluate-action&gt;
    &lt;transition on="CORRECT" to="showAnswer"/&gt;
    &lt;transition on="*" to="enterGuess"/&gt;
    &lt;transition on-exception="java.lang.NumberFormatException" to="enterGuess"/&gt;
&lt;/action-state&gt;
                </programlisting>
            </para>
            <para>
                The makeGuess action state consists of one evaluate action and three
                transitions. Evaluate actions are used to invoke logic encapsulated
                in a FLOW-scoped object - in this case the game bean. 
                The makeGuess method of the game bean returns one of several enum 
                values it defines:
                <programlisting>
enum GuessResult {
    TOO_HIGH, TOO_LOW, CORRECT, INVALID
}
                </programlisting>
                Web Flow detects the returned result from the makeGuess method
                is a JDK 1.5 enum type and 
                creates an Event with a String id matching the enum value. If the
                makeGuess method returns CORRECT a transition to the final 
                showAnswer state occurs. For any other event (defined with the event 
                pattern on="*") Web Flow returns to the enterGuess 
                state. The makeGuess state also defines one on-exception transition
                demonstrating how specific Exceptions can be incorporated into
                flow transition logic.
            </para>
            <para>
                The end-state showAnswer resolves to the JSP page 
                /WEB-INF/jsp/higherlower.showAnswer.jsp, which simply shows the
                correct guess. At this point the flow has ended and the "game" bean 
                is no longer in scope.
            </para>
        </sect2>
        <sect2>
            <title>Mastermind Flow</title>
            <para>
                The mastermind flow uses a similar flow definition to implement a 4-digit
                guessing game:
                <programlisting>
&lt;var name="game" class="org.springframework.webflow.samples.numberguess.MastermindGame"/&gt;

&lt;start-state idref="enterGuess"/&gt;

&lt;view-state id="enterGuess" view="mastermind.enterGuess"&gt;
    &lt;transition on="submit" to="makeGuess"/&gt;
&lt;/view-state&gt;

&lt;action-state id="makeGuess"&gt;
    &lt;evaluate-action expression="flowScope.game.makeGuess(requestParameters.guess)"&gt;
        &lt;evaluation-result name="guessResult"/&gt;
    &lt;/evaluate-action&gt;
    &lt;transition on="CORRECT" to="showAnswer"/&gt;
    &lt;transition on="*" to="enterGuess"/&gt;
&lt;/action-state&gt;

&lt;end-state id="showAnswer" view="mastermind.showAnswer"/&gt;
                </programlisting>
                The MastermindGame class encapsulates the logic for the game and 
                is stored as a FLOW-scoped bean. 
                It returns one of three possible enum values -
                WRONG, CORRECT, or INVALID, which Web Flow converts to events with 
                id's matching the enum values. If the guess is INVALID the JSP page
                /WEB-INF/jsp/mastermind.enterGuess.jsp will print an error message.
                If the guess is CORRECT the flow will transition to the showAnswer 
                end state and complete the flow.
            </para>
        </sect2>
    </sect1>    
</chapter>
